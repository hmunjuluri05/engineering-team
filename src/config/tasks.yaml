design_task:
  description: >
    Take the high level requirements and prepare a detailed design for the engineer.
    Analyze what is being built and determine the appropriate file structure and architecture.
    For simple applications, a single module might suffice. For complex applications, design a modular structure with multiple files and folders.

    IMPORTANT: At the beginning of your design, include a "Components Needed" section that clearly states:
    - Backend/Core Implementation: REQUIRED (always needed)
    - User Interface: REQUIRED or NOT REQUIRED (based on project type)
    - Automated Tests: REQUIRED or NOT REQUIRED (production code needs tests, simple prototypes may not)

    Include in your design:
    - Project type (CLI tool, library, API service, web app with UI, etc.)
    - Components needed (Backend: YES, UI: YES/NO, Tests: YES/NO)
    - Recommended folder structure
    - File names for each module (including requirements.txt for dependencies)
    - Class and function definitions for each file
    - How the modules interact with each other
    - Required dependencies for the application (to be listed in requirements.txt)

    Here are the requirements: {requirements}
    IMPORTANT: Only output the design in markdown format, laying out in detail the architecture, files, classes and functions.
    Save this design to a file named docs/DESIGN.md (the docs folder will be created automatically)
  expected_output: >
    A detailed design document in markdown format (docs/DESIGN.md) that:
    1. Starts with a "Components Needed" section (Backend, UI, Tests - each marked REQUIRED or NOT REQUIRED)
    2. Identifies the project type
    3. Specifies the folder structure (if complex)
    4. Lists all files that should be created (including requirements.txt)
    5. Identifies the classes and functions in each file
    6. Describes the functionality of each component
    7. Explains how modules interact with each other
    8. Lists required Python dependencies for the application
  agent: engineering_lead
  output_file: docs/DESIGN.md

code_task:
  description: >
    Review the design specification to determine what backend/core implementation is needed.

    Implement the design described by the engineering lead.
    Follow the exact file structure, filenames, and class names specified in the design.
    Create as many files and folders as specified in the design - use save_to_file for each file you create.
    For complex applications, create a modular codebase with proper separation of concerns.
    For simple applications, a single file may suffice.
    The implementation must be completely self-contained and ready for testing and UI development.

    IMPORTANT - File Organization:
    - Save ALL Python code files in the src/ folder (e.g., src/main.py, src/models/user.py)
    - Save requirements.txt in the ROOT folder (not in src/)
    - Create a README.md in the ROOT folder with:
      * Project description
      * Installation instructions (pip install -r requirements.txt)
      * How to run the application
      * Project structure overview
      * Any configuration needed

    IMPORTANT - Dependencies:
    - Create requirements.txt listing all Python dependencies needed to run the application
    - Include dependencies based on what's specified in the design (e.g., gradio for UI apps, pytest for tested apps)
    - Use appropriate version specifiers (e.g., gradio>=4.0.0)
    - One dependency per line with version constraints

    Here are the requirements: {requirements}
  expected_output: >
    A complete Python implementation following the design specification.
    Create all files and folders as specified in the design document.
    Use save_to_file(content, filename) for each file you create.

    MUST include (in order of importance):
    1. requirements.txt in ROOT folder with all necessary dependencies
    2. README.md in ROOT folder with installation and usage instructions
    3. All Python code files in src/ folder

    Examples:
    - save_to_file(requirements_content, "requirements.txt")
    - save_to_file(readme_content, "README.md")
    - save_to_file(code, "src/main.py")
    - save_to_file(models_code, "src/models/user.py")
    - save_to_file(utils_code, "src/utils/helpers.py")

    IMPORTANT:
    - For Python files, output ONLY raw Python code without markdown formatting or code block delimiters
    - For requirements.txt, output plain text with one dependency per line
    - For README.md, output in markdown format with clear sections
  agent: backend_engineer
  context:
    - design_task

frontend_task:
  description: >
    Review the design specification and requirements to determine if a user interface is needed.

    IMPORTANT: Check the "Components Needed" section in the design document:
    - If "User Interface: NOT REQUIRED" → output "NO UI REQUIRED" and skip UI creation
    - If the project is a CLI tool, library, API service, or backend-only service → output "NO UI REQUIRED"
    - Only create a UI if the design explicitly states "User Interface: REQUIRED"

    If UI is needed:
    - Create a Gradio UI based on the design specification
    - Review the design document to understand the backend architecture, classes, and methods
    - Create a simple, intuitive UI for interacting with the backend as specified in the design
    - IMPORTANT: Save the main UI file as app.py in the ROOT folder (not in src/)
    - For complex applications, you may create additional UI components in src/ui/ folder
    - Use save_to_file for each file you create
    - Assume there is only 1 user, and keep the UI simple - just a prototype or demo
    - Import the backend classes from src/ folder (e.g., from src.models import User)

    Here are the requirements: {requirements}
  expected_output: >
    EITHER:
    1. "NO UI REQUIRED" if the project doesn't need a graphical user interface (CLI tools, libraries, APIs, backend services)

    OR:

    2. A Gradio UI (typically app.py) based on the design specification if UI is needed.
       Create additional UI files if needed for complex applications using save_to_file.
       The main app.py should be in the ROOT folder and import from src/.
       It should properly import the backend classes as specified in the design and provide a functional interface.
       Examples:
       - save_to_file(app_code, "app.py")  # Main UI in ROOT
       - save_to_file(components_code, "src/ui/components.py")  # UI components in src/ui/
       IMPORTANT: For each file, output ONLY raw Python code without markdown formatting or code block delimiters.
  agent: frontend_engineer
  context:
    - design_task

test_task:
  description: >
    Review the design specification and requirements to determine if automated tests are needed.

    IMPORTANT: Check the "Components Needed" section in the design document:
    - If "Automated Tests: NOT REQUIRED" → output "NO TESTS REQUIRED" and skip test creation
    - If this is a simple throwaway script, prototype, or example code → output "NO TESTS REQUIRED"
    - Only create tests if the design explicitly states "Automated Tests: REQUIRED"

    If tests are needed:
    - Write comprehensive unit tests based on the design specification
    - Review the design document to understand the backend architecture, classes, methods, and expected behavior
    - Create tests that cover all functionality specified in the design
    - IMPORTANT: Save ALL test files in the tests/ folder
    - For simple applications, create a single test file (e.g., tests/test_main.py)
    - For complex applications with multiple modules, create multiple test files (e.g., tests/test_models.py, tests/test_services.py)
    - Create tests/conftest.py for pytest fixtures if needed
    - Use save_to_file for each test file you create
    - Follow pytest conventions and use the test_<module_name>.py naming convention
    - Import the backend classes from src/ folder (e.g., from src.models import User)

    Here are the requirements: {requirements}
  expected_output: >
    EITHER:
    1. "NO TESTS REQUIRED" if the design/requirements indicate tests are not needed (simple scripts, prototypes, examples)

    OR:

    2. Comprehensive unit tests based on the design specification.
       Create as many test files as needed to properly test all modules specified in the design.
       Use save_to_file(content, filename) for each test file.
       Examples:
       - save_to_file(test_code, "tests/test_main.py")  # All tests in tests/ folder
       - save_to_file(model_tests, "tests/test_models.py")
       - save_to_file(service_tests, "tests/test_services.py")
       - save_to_file(conftest_code, "tests/conftest.py")
       IMPORTANT: For each file, output ONLY raw Python code without markdown formatting or code block delimiters.
  agent: test_engineer
  context:
    - design_task
